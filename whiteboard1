import tkinter as tk
import math
from tkinter import messagebox  # NEW: For premium dialogs
from collections import defaultdict

class WhiteboardApp:
    # NEW: Premium dialog method
    def show_premium_dialog(self, feature="this feature"):
        from tkinter import messagebox
        messagebox.showinfo("Premium Feature", f"{feature} requires a premium license. Please upgrade to access this feature.")
    def __init__(self, root):
        # NEW: Premium flag (False for public; set True for premium)
        self.is_premium = False  # TODO: In premium, set to True or check os.environ.get('PREMIUM_KEY') == 'valid_key'
        self.root = root
        self.root.title("Whiteboard Application")
        
        # Set initial window size
        self.root.geometry("800x600")
        
         # Create a frame for buttons
        self.button_frame = tk.Frame(root)
        self.button_frame.pack(pady=5)
        
        # Add Undo and Reset buttons
        self.undo_button = tk.Button(self.button_frame, text="Undo", command=self.undo_last_unit)
        self.undo_button.pack(side=tk.LEFT, padx=5)
        self.reset_button = tk.Button(self.button_frame, text="Reset", command=self.reset_all)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        
        # Add legend
        self.legend = tk.Label(self.button_frame, text=f"π ≈ {self.format_number(math.pi)} | e ≈ {self.format_number(math.e)}", font=('Arial', 8))
        self.legend.pack(side=tk.RIGHT, padx=5)
        
        # Create a blank canvas
        self.canvas = tk.Canvas(root, bg="gray50")
        self.canvas.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        
        # State variables (GUARDED: Skip premium vars if not premium)
        self.points = {}          # {point_id: (x, y, color)}
        self.arrows = {}          # {arrow_id: (source_point_id, target_point_id)}
        self.units = []           # List of unit dicts: {'unit_id': id, 'output': target_id, 'input1': source1_id, 'input2': source2_id, 'blue': id, 'yellow': id, 'red': id, 'arrows': [arrow_id1, arrow_id2], 'operation': None/"addition"/"multiplication"/"logarithmic", 'operation_label': text_id or 'operation_labels': {'yellow': id, 'blue': id, 'red': id}}
        self.point_units = {}     # {point_id: unit_id}
        self.point_numbers = {}   # {point_id: number}
        self.point_number_labels = {}  # {point_id: text_id} for number labels
        self.selected_points = set()  # Set of selected point IDs for current building group
        self.linked_groups = []       # List of sets for committed linked groups
        self.point_to_group = {}      # {point_id: group_index}
        self.selected_units = set()   # Set of selected unit IDs
        self.selected_outputs = []    # List of selected output points for linking
        self.cell_links = []          # List of {'start': p_id, 'end': p_id, 'arrow_id': id}
        self.cell_graph = defaultdict(list)  # For cycle detection: start -> [ends]
        self.dragging_item = None
        self.dragging_type = None    # 'point', 'text', or 'group'
        self.dragging_units = None
        self.dragging_text_id = None
        self.initial_positions = None
        self.init_mouse_x = None
        self.init_mouse_y = None
        self.init_drag_x = None
        self.init_drag_y = None
        # PREMIUM: Only init if premium
        if self.is_premium:
            self.fixed_timers = {}       # {point_id: after_id} for fixed +1 timers
            self.point_steps = {}        # {point_id: step_size}
        self.next_unit_id = 1     # For assigning unique unit IDs
        self.editing_entry = None # Track active Entry widget
        self.red_context_point = None
        self.yellow_context_point = None
        # PREMIUM: Only init if premium
        if self.is_premium:
            self.next_report_y = 30
            self.report_positions = {}
        self.texts = {}             # {text_id: (x, y, content)}
        self.text_handles = {}      # {text_id: handle_id}
        self.editing_text = None    # text_id being edited or None for new
        self.editing_text_widget = None
        self.new_text_pos = None
        self.context_text_id = None
        
        # Context menu for blue point operations
        self.context_menu = tk.Menu(self.canvas, tearoff=0)
        self.context_menu.add_command(label="Addition", command=self.enable_addition)
        self.context_menu.add_command(label="Multiplication", command=self.enable_multiplication)
        self.context_menu.add_command(label="Logarithmic", command=self.enable_logarithmic)
        # PREMIUM: Conditionally add Riemann
        if self.is_premium:
            self.context_menu.add_command(label="Riemann Sum", command=self.enable_riemann_sum)
        else:
            self.context_menu.add_command(label="Riemann Sum (Premium)", command=self.show_premium_dialog, state="disabled")
        
        # PREMIUM: Context menus only if premium
        if self.is_premium:
            # Context menu for red point timer
            self.red_context_menu = tk.Menu(self.canvas, tearoff=0)
            self.red_context_menu.add_command(label="t", command=self.toggle_red_timer, font=('Arial', 12, 'bold'))
            self.red_context_menu.add_command(label="delta", command=self.apply_red_delta, font=('Arial', 10, 'bold'))
            
            # Context menu for yellow point timer
            self.yellow_context_menu = tk.Menu(self.canvas, tearoff=0)
            self.yellow_context_menu.add_command(label="t", command=self.toggle_yellow_timer, font=('Arial', 12, 'bold'))
            self.yellow_context_menu.add_command(label="delta", command=self.apply_yellow_delta, font=('Arial', 10, 'bold'))
        
        # Context menu for text
        self.text_context_menu = tk.Menu(self.canvas, tearoff=0)
        self.text_context_menu.add_command(label="Edit", command=self.edit_text)
        self.text_context_menu.add_command(label="Delete", command=self.delete_text)
        
        # Bindings
        self.canvas.bind("<Control-Double-Button-1>", self.handle_control_double_click)
        self.canvas.bind("<Button-1>", self.start_drag)
        self.canvas.bind("<B1-Motion>", self.drag_item)
        self.canvas.bind("<ButtonRelease-1>", self.stop_drag)
        self.canvas.bind("<Double-Button-1>", self.handle_double_click)
        self.canvas.bind("<Button-3>", self.show_context_menu)
        self.canvas.bind("<Control-Button-1>", self.toggle_select)
        self.canvas.bind("<Shift-Button-1>", self.toggle_unit_select)
        self.canvas.bind("<Control-Alt-Button-1>", self.toggle_output_select)
        self.root.bind("<KeyRelease-Control_L>", self.on_ctrl_release)
        self.root.bind("<KeyRelease-Control_R>", self.on_ctrl_release)
        # Mouse scroll bindings
        self.canvas.bind("<MouseWheel>", self.handle_scroll)  # Windows
        self.canvas.bind("<Button-4>", self.handle_scroll)   # Linux (scroll up)
        self.canvas.bind("<Button-5>", self.handle_scroll)   # Linux (scroll down)
        # Text double-click binding
        self.canvas.tag_bind("text", "<Double-Button-1>", self.on_text_double_click)
    
    def format_number(self, value):
        """Format a number to up to 4 decimal places with thousands separators, removing trailing zeros and decimal point if unnecessary."""
        # Format to 4 decimals first
        s = format(value, '.4f')
        
        # Add thousands separators to the integer part
        if '.' in s:
            int_part, dec_part = s.split('.')
            int_part = '{:,}'.format(int(int_part))  # Adds commas to integer
            s = int_part + '.' + dec_part
        else:
            s = '{:,}'.format(int(s))
        
        # Strip trailing zeros and decimal point if no decimals remain
        if '.' in s:
            s = s.rstrip('0').rstrip('.')
        return s
    
    def on_ctrl_release(self, event):
        if self.selected_points:
            new_group = self.selected_points.copy()
            self.linked_groups.append(new_group)
            for p in new_group:
                self.point_to_group[p] = len(self.linked_groups) - 1
                self.canvas.itemconfig(p, outline="", width=1)
            self.selected_points.clear()
    
    def toggle_select(self, event):
        items = self.canvas.find_closest(event.x, event.y)
        if not items:
            return "break"
        clicked_item = items[0]
        if "point" not in self.canvas.gettags(clicked_item):
            return "break"
        point_id = clicked_item
        
        if point_id in self.point_to_group:
            # Unlink the point
            group_idx = self.point_to_group[point_id]
            if group_idx < len(self.linked_groups):
                self.linked_groups[group_idx].discard(point_id)
                if not self.linked_groups[group_idx]:
                    del self.linked_groups[group_idx]
                    # Update indices for higher groups
                    for higher_p, higher_idx in list(self.point_to_group.items()):
                        if higher_idx > group_idx:
                            self.point_to_group[higher_p] -= 1
            del self.point_to_group[point_id]
            self.canvas.itemconfig(point_id, outline="", width=1)
        elif point_id in self.selected_points:
            # Deselect from current selection
            self.selected_points.remove(point_id)
            self.canvas.itemconfig(point_id, outline="", width=1)
        else:
            # Limit to 3 points for new selection
            if len(self.selected_points) >= 3:
                return "break"
            # If there are already selected points, set this point's value to the group's value
            if self.selected_points:
                group_value = self.point_numbers[next(iter(self.selected_points))]
                self.point_numbers[point_id] = group_value
                if point_id in self.point_number_labels:
                    label_id = self.point_number_labels[point_id]
                    self.canvas.itemconfig(label_id, text=self.format_number(group_value))
                # Update the unit output if applicable
                u_id = self.point_units.get(point_id)
                if u_id:
                    self.update_unit_numbers(u_id)
            # Select
            self.selected_points.add(point_id)
            self.canvas.itemconfig(point_id, outline="black", width=2)
        return "break"
    
    def toggle_output_select(self, event):
        items = self.canvas.find_closest(event.x, event.y)
        if not items:
            return "break"
        clicked_item = items[0]
        if "point" not in self.canvas.gettags(clicked_item):
            return "break"
        point_id = clicked_item
        unit_id = self.point_units.get(point_id)
        if not unit_id:
            return "break"
        unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
        if not unit or point_id != unit['output']:
            return "break"
        
        if point_id in self.selected_outputs:
            self.selected_outputs.remove(point_id)
            self.canvas.itemconfig(point_id, outline="", width=1)
        else:
            if len(self.selected_outputs) >= 2:
                return "break"
            self.selected_outputs.append(point_id)
            self.canvas.itemconfig(point_id, outline="purple", width=2)
            if len(self.selected_outputs) == 2:
                start_id = self.selected_outputs[0]
                end_id = self.selected_outputs[1]
                self.create_cell_link(start_id, end_id)
                # Deselect
                for p in [start_id, end_id]:
                    self.canvas.itemconfig(p, outline="", width=1)
                self.selected_outputs.clear()
        return "break"
    
    def toggle_unit_select(self, event):
        items = self.canvas.find_closest(event.x, event.y)
        if not items:
            return "break"
        clicked_item = items[0]
        if "point" not in self.canvas.gettags(clicked_item):
            return "break"
        point_id = clicked_item
        unit_id = self.point_units.get(point_id)
        if not unit_id:
            return "break"
        unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
        if not unit:
            return "break"
        
        if unit_id in self.selected_units:
            self.selected_units.remove(unit_id)
            for p_id in [unit['blue'], unit['yellow'], unit['red']]:
                self.canvas.itemconfig(p_id, outline="", width=1)
        else:
            self.selected_units.add(unit_id)
            for p_id in [unit['blue'], unit['yellow'], unit['red']]:
                self.canvas.itemconfig(p_id, outline="green", width=2)
        return "break"
    
    def get_group_for_point(self, point_id):
        """Get the group set for a point, whether in linked_groups or selected_points."""
        if point_id in self.point_to_group:
            group_idx = self.point_to_group[point_id]
            return self.linked_groups[group_idx]
        elif point_id in self.selected_points:
            return self.selected_points
        else:
            return {point_id}
    
    def show_context_menu(self, event):
        # Find the clicked item
        items = self.canvas.find_closest(event.x, event.y)
        if not items:
            return
        clicked_item = items[0]
        tags = self.canvas.gettags(clicked_item)
        if "point" in tags:
            color = self.points[clicked_item][2]
            # PREMIUM: Guard red/yellow menus
            if color == 'red':
                if self.is_premium:
                    self.show_red_menu(event, clicked_item)
                else:
                    self.show_premium_dialog("Time Timer (Red)")
                return
            elif color == 'yellow':
                if self.is_premium:
                    self.show_yellow_menu(event, clicked_item)
                else:
                    self.show_premium_dialog("Time Timer (Yellow)")
                return
            
            # Check if the point is the blue point of its unit
            unit_id = self.point_units.get(clicked_item)
            if not unit_id:
                return
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if not unit or clicked_item != unit['blue']:
                return
            
            # Store the unit ID for the context menu action
            self.context_menu_unit_id = unit_id
            # Show the context menu
            self.context_menu.post(event.x_root, event.y_root)
        elif "text" in tags or ("text_handle" in tags and len(tags) > 1):
            if "text" in tags:
                text_id = clicked_item
            else:
                # Parse text_id from handle tags
                text_id_str = [t for t in tags if t.isdigit()][0]
                text_id = int(text_id_str)
            self.context_text_id = text_id
            self.text_context_menu.post(event.x_root, event.y_root)
    
    def show_red_menu(self, event, point_id):
        self.red_context_point = point_id
        self.red_context_menu.post(event.x_root, event.y_root)
    
    def show_yellow_menu(self, event, point_id):
        self.yellow_context_point = point_id
        self.yellow_context_menu.post(event.x_root, event.y_root)
    
    def edit_text(self):
        text_id = self.context_text_id
        if text_id not in self.texts:
            return
        x, y, _ = self.texts[text_id]
        self.edit_text_at(text_id, x, y)
    
    def delete_text(self):
        text_id = self.context_text_id
        if text_id in self.texts:
            handle_id = self.text_handles.get(text_id)
            if handle_id:
                self.canvas.delete(handle_id)
                del self.text_handles[text_id]
            self.canvas.delete(text_id)
            del self.texts[text_id]
    
    def on_text_double_click(self, event):
        item = self.canvas.find_closest(event.x, event.y)
        if len(item) == 0 or "text" not in self.canvas.gettags(item[0]):
            return
        text_id = item[0]
        x, y, _ = self.texts[text_id]
        self.edit_text_at(text_id, x, y)
    
    def edit_text_at(self, text_id, x, y):
        content = self.texts.get(text_id, ("", "", ""))[2]
        if self.editing_text_widget:
            self.finish_edit_text()
        self.editing_text = text_id
        widget = tk.Text(self.canvas, wrap=tk.WORD, width=20, height=5, bg="white", relief="solid", bd=1)
        widget.place(x=x, y=y, anchor="nw")
        widget.insert("1.0", content)
        widget.focus_set()
        widget.bind("<Return>", self.on_text_enter)
        widget.bind("<Shift-Return>", self.on_shift_return)
        widget.bind("<Escape>", self.cancel_edit_text)
        self.editing_text_widget = widget
        self.canvas.itemconfig(text_id, state="hidden")
        handle_id = self.text_handles.get(text_id)
        if handle_id:
            self.canvas.itemconfig(handle_id, state="hidden")
    
    def on_shift_return(self, event):
        self.editing_text_widget.insert(tk.INSERT, "\n")
        return "break"
    
    def on_text_enter(self, event):
        self.finish_edit_text()
        return "break"
    
    def start_new_text(self, x, y):
        if self.editing_text_widget:
            self.finish_edit_text()
        self.editing_text = None
        self.new_text_pos = (x, y)
        widget = tk.Text(self.canvas, wrap=tk.WORD, width=20, height=5, bg="white", relief="solid", bd=1)
        widget.place(x=x, y=y, anchor="nw")
        widget.focus_set()
        widget.bind("<Return>", self.on_text_enter)
        widget.bind("<Shift-Return>", self.on_shift_return)
        widget.bind("<Escape>", self.cancel_edit_text)
        self.editing_text_widget = widget
    
    def finish_edit_text(self):
        if not self.editing_text_widget:
            return
        content = self.editing_text_widget.get("1.0", tk.END).rstrip()
        stripped_content = content.strip()
        if not stripped_content:
            # Empty, cancel
            self.editing_text_widget.destroy()
            self.editing_text_widget = None
            self.editing_text = None
            if hasattr(self, 'new_text_pos'):
                del self.new_text_pos
            return
        if self.editing_text is None:
            # New text
            x, y = self.new_text_pos
            del self.new_text_pos
            text_id = self.canvas.create_text(x, y, text=content, anchor="nw", fill="black", tags="text")
            # Create handle
            handle_id = self.canvas.create_oval(x-3, y-3, x+3, y+3, fill="black", outline="black", tags=("text_handle", str(text_id)))
            self.texts[text_id] = (x, y, content)
            self.text_handles[text_id] = handle_id
        else:
            # Edit existing
            text_id = self.editing_text
            x, y, old_content = self.texts[text_id]
            handle_id = self.text_handles.get(text_id)
            self.canvas.delete(text_id)
            if handle_id:
                self.canvas.delete(handle_id)
            new_text_id = self.canvas.create_text(x, y, text=content, anchor="nw", fill="black", tags="text")
            new_handle_id = self.canvas.create_oval(x-3, y-3, x+3, y+3, fill="black", outline="black", tags=("text_handle", str(new_text_id)))
            self.texts[new_text_id] = (x, y, content)
            self.text_handles[new_text_id] = new_handle_id
            del self.texts[text_id]
            del self.text_handles[text_id]
            # Update context if applicable
            if hasattr(self, 'context_text_id') and self.context_text_id == text_id:
                self.context_text_id = new_text_id
        self.editing_text_widget.destroy()
        self.editing_text_widget = None
        self.editing_text = None
    
    def cancel_edit_text(self, event=None):
        if self.editing_text_widget:
            self.editing_text_widget.destroy()
            self.editing_text_widget = None
            if self.editing_text is not None:
                self.canvas.itemconfig(self.editing_text, state="normal")
                handle_id = self.text_handles.get(self.editing_text)
                if handle_id:
                    self.canvas.itemconfig(handle_id, state="normal")
            self.editing_text = None
            if hasattr(self, 'new_text_pos'):
                del self.new_text_pos
    
    def toggle_red_timer(self):
        if not self.is_premium:
            self.show_premium_dialog("Time Timer (t)")
            return
        point_id = self.red_context_point
        if point_id in self.fixed_timers:
            self.root.after_cancel(self.fixed_timers[point_id])
            del self.fixed_timers[point_id]
        else:
            self.increment_fixed(point_id)
    
    def toggle_yellow_timer(self):
        if not self.is_premium:
            self.show_premium_dialog("Time Timer (t)")
            return
        point_id = self.yellow_context_point
        if point_id in self.fixed_timers:
            self.root.after_cancel(self.fixed_timers[point_id])
            del self.fixed_timers[point_id]
        else:
            self.increment_fixed(point_id)
    
    def increment_fixed(self, point_id):
        if not self.is_premium:
            self.show_premium_dialog("Time/Riemann Feature")
            return
        group = self.get_group_for_point(point_id)
        if point_id in self.point_numbers:
            old_value = self.point_numbers[point_id]
            new_value = round(old_value + 1.0, 4)
            for p in group:
                self.point_numbers[p] = new_value
                if p in self.point_number_labels:
                    label_id = self.point_number_labels[p]
                    self.canvas.itemconfig(label_id, text=self.format_number(new_value))
            # Update affected units
            affected_units = set(self.point_units.get(p) for p in group if self.point_units.get(p))
            for u_id in affected_units:
                self.update_unit_numbers(u_id)
            # Handle riemann accumulation if this is the yellow point
            if old_value != new_value:
                unit_id = self.point_units.get(point_id)
                if unit_id:
                    unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
                    if unit and unit['operation'] == 'riemann_sum' and point_id == unit['yellow']:
                        self._handle_riemann_accumulation(unit, new_value, old_value)
            # Propagate from the timed point (triggers accumulation if Riemann yellow)
            self.propagate_update(point_id, new_value)
        self.fixed_timers[point_id] = self.root.after(1000, lambda pid=point_id: self.increment_fixed(pid))
    
    def apply_red_delta(self):
        if not self.is_premium:
            self.show_premium_dialog("Time/Riemann Feature")
            return
        if not self.red_context_point:
            return
        point_id = self.red_context_point
        top = tk.Toplevel(self.root)
        top.title("Apply Delta")
        top.geometry("200x100")
        top.transient(self.root)
        top.grab_set()
        tk.Label(top, text="Enter delta value:").pack(pady=10)
        entry = tk.Entry(top)
        entry.pack(pady=5)
        entry.insert(0, "1.0")
        def ok():
            try:
                delta = float(entry.get())
                group = self.get_group_for_point(point_id)
                if point_id in self.point_numbers:
                    value = self.point_numbers[point_id]
                    new_value = round(value + delta, 4)
                    for p in group:
                        self.point_numbers[p] = new_value
                        if p in self.point_number_labels:
                            label_id = self.point_number_labels[p]
                            self.canvas.itemconfig(label_id, text=self.format_number(new_value))
                        # Propagate update for every changed point
                        self.propagate_update(p, new_value)
                    # Update affected units
                    affected_units = set(self.point_units.get(p) for p in group if self.point_units.get(p))
                    for u_id in affected_units:
                        self.update_unit_numbers(u_id)
                    # Set step size based on delta
                    step_size = abs(delta) if delta != 0 else 0.1
                    self.point_steps[point_id] = step_size
                top.destroy()
            except ValueError:
                pass
        def cancel():
            top.destroy()
        tk.Button(top, text="OK", command=ok).pack(side=tk.LEFT, padx=10)
        tk.Button(top, text="Cancel", command=cancel).pack(side=tk.LEFT)
        entry.focus()
        entry.bind("<Return>", lambda e: ok())
        entry.bind("<Escape>", lambda e: cancel())
    
    def apply_yellow_delta(self):
        if not self.is_premium:
            self.show_premium_dialog("Time/Riemann Feature")
            return
        if not self.yellow_context_point:
            return
        point_id = self.yellow_context_point
        top = tk.Toplevel(self.root)
        top.title("Apply Delta")
        top.geometry("200x100")
        top.transient(self.root)
        top.grab_set()
        tk.Label(top, text="Enter delta value:").pack(pady=10)
        entry = tk.Entry(top)
        entry.pack(pady=5)
        entry.insert(0, "1.0")
        def ok():
            try:
                delta = float(entry.get())
                group = self.get_group_for_point(point_id)
                if point_id in self.point_numbers:
                    value = self.point_numbers[point_id]
                    new_value = round(value + delta, 4)
                    for p in group:
                        self.point_numbers[p] = new_value
                        if p in self.point_number_labels:
                            label_id = self.point_number_labels[p]
                            self.canvas.itemconfig(label_id, text=self.format_number(new_value))
                        # Propagate update for every changed point
                        self.propagate_update(p, new_value)
                    # Update affected units
                    affected_units = set(self.point_units.get(p) for p in group if self.point_units.get(p))
                    for u_id in affected_units:
                        self.update_unit_numbers(u_id)
                    # Set step size based on delta
                    step_size = abs(delta) if delta != 0 else 0.1
                    self.point_steps[point_id] = step_size
                top.destroy()
            except ValueError:
                pass
        def cancel():
            top.destroy()
        tk.Button(top, text="OK", command=ok).pack(side=tk.LEFT, padx=10)
        tk.Button(top, text="Cancel", command=cancel).pack(side=tk.LEFT)
        entry.focus()
        entry.bind("<Return>", lambda e: ok())
        entry.bind("<Escape>", lambda e: cancel())
    
    def create_cell_link(self, start, end):
        if start == end:
            return
        if self.point_units[start] == self.point_units[end]:
            return
        if any(l['end'] == end for l in self.cell_links):
            return
        if self.has_cycle(start, end):
            return
        sx, sy, _ = self.points[start]
        ex, ey, _ = self.points[end]
        arrow_id = self.canvas.create_line(sx, sy, ex, ey, arrow=tk.LAST, dash=(4, 2), fill="white", tags="link_arrow")
        link = {'start': start, 'end': end, 'arrow_id': arrow_id}
        self.cell_links.append(link)
        self.cell_graph[start].append(end)
        self.propagate_update(end, self.point_numbers[start])
    
    def has_cycle(self, start, end):
        visited = set()
        def dfs(node):
            visited.add(node)
            for neigh in self.cell_graph[node]:
                if neigh == start:
                    return True
                if neigh not in visited:
                    if dfs(neigh):
                        return True
            return False
        return dfs(end)
    
    def propagate_update(self, point_id, value):
        old_value = self.point_numbers.get(point_id, 0.0)
        self.point_numbers[point_id] = value
        if point_id in self.point_number_labels:
            self.canvas.itemconfig(self.point_number_labels[point_id], text=self.format_number(value))
        
        # Handle riemann accumulation if this is yellow input for riemann unit
        unit_id = self.point_units.get(point_id)
        if unit_id:
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if unit and unit['operation'] == 'riemann_sum' and point_id == unit['yellow'] and old_value != value:
                self._handle_riemann_accumulation(unit, value, old_value)
        
        # If this point is an input to its unit, trigger unit recalc
        if unit_id:
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if unit and point_id != unit['output']:  # Only if it's an input
                self.update_unit_numbers(unit_id)
        
        # Propagate to outgoing links
        for link in self.cell_links:
            if link['start'] == point_id:
                self.propagate_update(link['end'], value)
    
    def _remove_previous_operation_labels(self, unit):
        prev_op = unit.get('operation')
        unit_id = unit['unit_id']
        if prev_op:
            if prev_op == 'riemann_sum':
                if 'running_sum' in unit:
                    del unit['running_sum']
                if 'history' in unit:
                    del unit['history']
                if 'report_id' in unit:
                    self.canvas.delete(unit['report_id'])
                    del unit['report_id']
                if unit_id in self.report_positions:
                    del self.report_positions[unit_id]
                if unit.get('operation_label'):
                    self.canvas.delete(unit['operation_label'])
                    unit['operation_label'] = None
            elif prev_op == 'logarithmic':
                if 'operation_labels' in unit:
                    for lid in unit['operation_labels'].values():
                        self.canvas.delete(lid)
                    del unit['operation_labels']
            else:
                if unit.get('operation_label'):
                    self.canvas.delete(unit['operation_label'])
                    unit['operation_label'] = None
    
    def enable_addition(self):
        if hasattr(self, 'context_menu_unit_id'):
            unit_id = self.context_menu_unit_id
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if unit:
                self._remove_previous_operation_labels(unit)
                # Enable addition
                unit['operation'] = 'addition'
                # Create operation symbol above blue point
                blue_id = unit['blue']
                blue_x, blue_y, _ = self.points[blue_id]
                label_id = self.canvas.create_text(blue_x, blue_y - 20, text="+", anchor="s", fill="blue", tags="operation_label")
                unit['operation_label'] = label_id
                # Update numbers
                self.update_unit_numbers(unit_id)
    
    def enable_multiplication(self):
        if hasattr(self, 'context_menu_unit_id'):
            unit_id = self.context_menu_unit_id
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if unit:
                self._remove_previous_operation_labels(unit)
                # Enable multiplication
                unit['operation'] = 'multiplication'
                # Create operation symbol above blue point
                blue_id = unit['blue']
                blue_x, blue_y, _ = self.points[blue_id]
                label_id = self.canvas.create_text(blue_x, blue_y - 20, text="*", anchor="s", fill="blue", tags="operation_label")
                unit['operation_label'] = label_id
                # Update numbers
                self.update_unit_numbers(unit_id)
    
    def enable_logarithmic(self):
        if hasattr(self, 'context_menu_unit_id'):
            unit_id = self.context_menu_unit_id
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if unit:
                self._remove_previous_operation_labels(unit)
                # Enable logarithmic
                unit['operation'] = 'logarithmic'
                # Create operation symbols above each point
                yellow_id = unit['yellow']
                y_x, y_y, _ = self.points[yellow_id]
                y_label_id = self.canvas.create_text(y_x, y_y - 20, text="Log", anchor="s", fill="#DAA520", tags="operation_label")
                
                blue_id = unit['blue']
                b_x, b_y, _ = self.points[blue_id]
                b_label_id = self.canvas.create_text(b_x, b_y - 20, text="Root", anchor="s", fill="blue", tags="operation_label")
                
                red_id = unit['red']
                r_x, r_y, _ = self.points[red_id]
                r_label_id = self.canvas.create_text(r_x, r_y - 20, text="Base", anchor="s", fill="red", tags="operation_label")
                
                unit['operation_labels'] = {
                    'yellow': y_label_id,
                    'blue': b_label_id,
                    'red': r_label_id
                }
                # Update numbers
                self.update_unit_numbers(unit_id)
    
    def enable_riemann_sum(self):
        if not self.is_premium:
            self.show_premium_dialog("Riemann Sum Operation")
            return
        if hasattr(self, 'context_menu_unit_id'):
            unit_id = self.context_menu_unit_id
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if unit:
                self._remove_previous_operation_labels(unit)
                # Enable riemann sum
                unit['operation'] = 'riemann_sum'
                current_yellow_value = self.point_numbers.get(unit['yellow'], 1.0)
                unit['running_sum'] = current_yellow_value
                unit['history'] = [(current_yellow_value, current_yellow_value)]
                self.report_positions[unit_id] = self.next_report_y
                self.next_report_y += 200
                # Create operation symbol above blue point
                blue_id = unit['blue']
                blue_x, blue_y, _ = self.points[blue_id]
                label_id = self.canvas.create_text(blue_x, blue_y - 20, text="∑", anchor="s", fill="blue", tags="operation_label")
                unit['operation_label'] = label_id
                # Update numbers
                self.update_unit_numbers(unit_id)
                self.update_riemann_report(unit)
    
    def _handle_riemann_accumulation(self, unit, new_yellow, old_yellow):
        if not self.is_premium:
            self.show_premium_dialog("Time/Riemann Feature")
            return
        if new_yellow == old_yellow:
            return
        if new_yellow < old_yellow:
            unit['running_sum'] = new_yellow
            unit['history'] = [(new_yellow, new_yellow)]
        else:
            unit['running_sum'] += new_yellow
            unit['history'].append((new_yellow, new_yellow))
        if len(unit['history']) > 50:
            unit['history'] = unit['history'][-50:]
        self.update_unit_numbers(unit['unit_id'])
        self.update_riemann_report(unit)
    
    def update_riemann_report(self, unit):
        if not self.is_premium:
            self.show_premium_dialog("Time/Riemann Feature")
            return
        # Delete previous report if exists
        if 'report_id' in unit:
            self.canvas.delete(unit['report_id'])
            del unit['report_id']
        history = unit.get('history', [])
        text = "Riemann History:\n"
        if history:
            if len(history) > 10:
                for x, fx in history[:5]:
                    text += f"f(x)={self.format_number(fx)}\n"
                text += "...\n"
                for x, fx in history[-5:]:
                    text += f"f(x)={self.format_number(fx)}\n"
            else:
                for x, fx in history:
                    text += f"f(x)={self.format_number(fx)}\n"
        current_red = self.point_numbers.get(unit['red'], 1.0)
        total = unit['running_sum'] * current_red
        text += f"Total: {self.format_number(total)}\n"
        y_pos = self.report_positions.get(unit['unit_id'], 30)
        report_id = self.canvas.create_text(10, y_pos, text=text, anchor="nw", fill="lightgray", font=('Arial', 8), tags="report")
        unit['report_id'] = report_id
    
    def update_unit_numbers(self, unit_id):
        # Find the unit
        unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
        if not unit or not unit.get('operation'):
            return
        
        output_id = unit['output']
        input1_id = unit['input1']
        input2_id = unit['input2']
        
        # Check for incoming link override
        incoming_link = next((l for l in self.cell_links if l['end'] == output_id), None)
        if incoming_link:
            start_id = incoming_link['start']
            output_value = self.point_numbers.get(start_id, 1.0)
        else:
            # Get current numbers
            input1_value = self.point_numbers.get(input1_id, 1.0)
            input2_value = self.point_numbers.get(input2_id, 1.0)
            blue_value = self.point_numbers.get(unit['blue'], 1.0)
            
            # Calculate output based on operation and output point
            if unit['operation'] == 'addition':
                if output_id == unit['blue']:  # Blue is output: blue = yellow + red
                    output_value = round(input1_value + input2_value, 4)
                elif output_id == unit['yellow']:  # Yellow is output: yellow = blue - red
                    red_value = self.point_numbers.get(unit['red'], 1.0)
                    output_value = round(blue_value - red_value, 4)
                elif output_id == unit['red']:  # Red is output: red = blue - yellow
                    yellow_value = self.point_numbers.get(unit['yellow'], 1.0)
                    output_value = round(blue_value - yellow_value, 4)
            elif unit['operation'] == 'multiplication':
                if output_id == unit['blue']:  # Blue is output: blue = yellow * red
                    output_value = round(input1_value * input2_value, 4)
                elif output_id == unit['yellow']:  # Yellow is output: yellow = blue / red
                    red_value = self.point_numbers.get(unit['red'], 1.0)
                    output_value = round(blue_value / red_value, 4) if red_value != 0 else 0.0
                elif output_id == unit['red']:  # Red is output: red = blue / yellow
                    yellow_value = self.point_numbers.get(unit['yellow'], 1.0)
                    output_value = round(blue_value / yellow_value, 4) if yellow_value != 0 else 0.0
            elif unit['operation'] == 'logarithmic':
                if output_id == unit['blue']:  # Blue is output: blue = red ^ yellow
                    red_value = self.point_numbers.get(unit['red'], 1.0)
                    yellow_value = self.point_numbers.get(unit['yellow'], 1.0)
                    try:
                        output_value = round(math.pow(red_value, yellow_value), 4)
                    except (ValueError, OverflowError):
                        output_value = 0.0  # Handle negative base or invalid exponent
                elif output_id == unit['yellow']:  # Yellow is output: yellow = log_red(blue)
                    red_value = self.point_numbers.get(unit['red'], 1.0)
                    try:
                        output_value = round(math.log(blue_value, red_value), 4) if blue_value > 0 and red_value > 0 and red_value != 1 else 0.0
                    except (ValueError, ZeroDivisionError):
                        output_value = 0.0  # Handle invalid log (negative/zero value, base=1)
                elif output_id == unit['red']:  # Red is output: red = blue^(1/yellow)
                    yellow_value = self.point_numbers.get(unit['yellow'], 1.0)
                    try:
                        output_value = round(math.pow(blue_value, 1.0 / yellow_value), 4) if blue_value >= 0 and yellow_value != 0 else 0.0
                    except (ValueError, ZeroDivisionError, OverflowError):
                        output_value = 0.0  # Handle invalid root (zero index, negative base)
            elif unit['operation'] == 'riemann_sum':
                if not self.is_premium:
                    self.show_premium_dialog("Riemann Calculation")  # Show once per update? Or log
                    output_value = 0.0  # Fallback
                else:
                    current_red_value = self.point_numbers.get(unit['red'], 1.0)
                    output_value = round(unit['running_sum'] * current_red_value, 4)
        
        # Update output number
        self.point_numbers[output_id] = output_value
        # Update output label
        if output_id in self.point_number_labels:
            self.canvas.itemconfig(self.point_number_labels[output_id], text=self.format_number(output_value))
        self.propagate_update(output_id, output_value)
    
    def handle_control_double_click(self, event):
        # Always create a standalone unit
        x, y = event.x, event.y
        radius = 8
        
        # Create yellow point
        yellow_id = self.canvas.create_oval(x - radius, y - radius, x + radius, y + radius, fill="yellow", tags="point")
        self.points[yellow_id] = (x, y, "yellow")
        self.point_numbers[yellow_id] = 1.0
        yellow_x, yellow_y = x, y
        yellow_label_id = self.canvas.create_text(x + 15, y + 15, text="1", tags="number_label", fill="white")
        self.point_number_labels[yellow_id] = yellow_label_id
        
        # Create red point
        red_x, red_y = x + 50, y
        red_id = self.canvas.create_oval(red_x - radius, red_y - radius, red_x + radius, red_y + radius, fill="red", tags="point")
        self.points[red_id] = (red_x, red_y, "red")
        self.point_numbers[red_id] = 1.0
        red_label_id = self.canvas.create_text(red_x + 15, red_y + 15, text="1", tags="number_label", fill="white")
        self.point_number_labels[red_id] = red_label_id
        
        # Create blue point at midpoint
        blue_x = (yellow_x + red_x) / 2
        blue_y = (yellow_y + red_y) / 2
        blue_id = self.canvas.create_oval(blue_x - radius, blue_y - radius, blue_x + radius, blue_y + radius, fill="blue", tags="point")
        self.points[blue_id] = (blue_x, blue_y, "blue")
        self.point_numbers[blue_id] = 1.0  # No operation by default
        blue_label_id = self.canvas.create_text(blue_x + 15, blue_y + 15, text="1", tags="number_label", fill="white")
        self.point_number_labels[blue_id] = blue_label_id
        
        # Create arrows: yellow -> blue, red -> blue
        arrow1_id = self.canvas.create_line(yellow_x, yellow_y, blue_x, blue_y, arrow=tk.LAST, fill="white", tags="arrow")
        arrow2_id = self.canvas.create_line(red_x, red_y, blue_x, blue_y, arrow=tk.LAST, fill="white", tags="arrow")
        self.arrows[arrow1_id] = (yellow_id, blue_id)
        self.arrows[arrow2_id] = (red_id, blue_id)
        
        # Store the unit
        unit = {
            'unit_id': self.next_unit_id,
            'output': blue_id,
            'input1': yellow_id,
            'input2': red_id,
            'blue': blue_id,
            'yellow': yellow_id,
            'red': red_id,
            'arrows': [arrow1_id, arrow2_id],
            'operation': None,
            'operation_label': None
        }
        self.units.append(unit)
        
        # Update point_units
        for point_id in [blue_id, yellow_id, red_id]:
            self.point_units[point_id] = unit['unit_id']
        
        self.next_unit_id += 1
        
        # Bind double-click on number labels
        for label_id in [yellow_label_id, red_label_id, blue_label_id]:
            self.canvas.tag_bind(label_id, "<Double-Button-1>", lambda e, pid=label_id: self.start_edit_number(e, pid))
    
    def handle_scroll(self, event):
        # Find the point under the cursor
        x, y = event.x, event.y
        items = self.canvas.find_overlapping(x - 8, y - 8, x + 8, y + 8)
        point_id = None
        for item in items:
            if "point" in self.canvas.gettags(item):
                point_id = item
                break
        if not point_id:
            return
        
        # Find the unit
        unit_id = self.point_units.get(point_id)
        if not unit_id:
            return
        unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
        if not unit:
            return
        
        # Only allow scroll on input points
        if point_id == unit['output']:
            return
        
        old_yellow = None
        # FIXED: Guard Riemann check for free version
        if self.is_premium and unit['operation'] == 'riemann_sum' and point_id == unit['yellow']:
            old_yellow = self.point_numbers[point_id]
        
        # Determine direction and step
        if event.type == "4":  # Button-4 (scroll up)
            direction = 1
        elif event.type == "5":  # Button-5 (scroll down)
            direction = -1
        else:  # MouseWheel
            direction = event.delta / 120  # Typically +1 or -1
        
        # FIXED: Guard point_steps access for free version (default to 0.1 if not premium)
        if self.is_premium:
            point_steps = self.point_steps
        else:
            point_steps = {}
        step = point_steps.get(point_id, 0.1)
        delta = direction * step
        
        # Determine group
        group = self.get_group_for_point(point_id)
        
        # Update the number and linked points
        if point_id in self.point_numbers:
            value = self.point_numbers[point_id]
            new_value = round(value + delta, 4)
            for p in group:
                self.point_numbers[p] = new_value
                if p in self.point_number_labels:
                    label_id = self.point_number_labels[p]
                    self.canvas.itemconfig(label_id, text=self.format_number(new_value))
                # Propagate for every point
                self.propagate_update(p, new_value)
            
            if old_yellow is not None:
                new_yellow = self.point_numbers[point_id]
                if old_yellow != new_yellow:
                    self._handle_riemann_accumulation(unit, new_yellow, old_yellow)
    
    def save_edit_number(self, point_id):
        if not self.editing_entry or point_id not in self.point_numbers:
            return
        try:
            new_value = float(self.editing_entry.get())
            new_value = round(new_value, 4)
            # Track old value for riemann
            old_yellow = None
            unit_id = self.point_units.get(point_id)
            unit = None
            if unit_id:
                unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
                # FIXED: Guard Riemann check
                if self.is_premium and unit and unit['operation'] == 'riemann_sum' and point_id == unit['yellow']:
                    old_yellow = self.point_numbers[point_id]
            # Determine group
            group = self.get_group_for_point(point_id)
            for p in group:
                self.point_numbers[p] = new_value
                if p in self.point_number_labels:
                    label_id = self.point_number_labels[p]
                    self.canvas.itemconfig(label_id, text=self.format_number(new_value))
                # Propagate for every point
                self.propagate_update(p, new_value)
            # Handle riemann accumulation (GUARDED)
            if self.is_premium and unit and unit['operation'] == 'riemann_sum' and point_id == unit['yellow']:
                self._handle_riemann_accumulation(unit, new_value, old_yellow)
        except ValueError:
            pass  # Ignore invalid input
        self.cancel_edit_number()
    
    def cancel_edit_number(self):
        if self.editing_entry:
            self.editing_entry.destroy()
            self.editing_entry = None
            self.editing_point_id = None
    
    def undo_last_unit(self):
        if not self.units:
            return
        
        # Get the last unit
        unit = self.units.pop()
        unit_id = unit['unit_id']
        if unit_id in self.selected_units:
            self.selected_units.remove(unit_id)
        
        # PREMIUM: Guard Riemann report deletion
        if self.is_premium and unit.get('operation') == 'riemann_sum':
            if 'report_id' in unit:
                self.canvas.delete(unit['report_id'])
            if hasattr(self, 'report_positions') and unit_id in self.report_positions:
                del self.report_positions[unit_id]
        
        # PREMIUM: Guard timer cleanup
        if self.is_premium:
            for point_id in [unit['blue'], unit['yellow'], unit['red']]:
                if point_id in self.fixed_timers:
                    self.root.after_cancel(self.fixed_timers[point_id])
                    del self.fixed_timers[point_id]
                if point_id in self.point_steps:
                    del self.point_steps[point_id]
        
        # Remove cell links involving this point (always, even free)
        for point_id in [unit['blue'], unit['yellow'], unit['red']]:
            to_remove = [l for l in self.cell_links if l['start'] == point_id or l['end'] == point_id]
            for l in to_remove:
                self.canvas.delete(l['arrow_id'])
                self.cell_links.remove(l)
                self.cell_graph[l['start']].remove(l['end'])
                if not self.cell_graph[l['start']]:
                    del self.cell_graph[l['start']]
        
        # Delete operation label(s) if exist
        if unit.get('operation_label'):
            self.canvas.delete(unit['operation_label'])
        if 'operation_labels' in unit:
            for lid in unit['operation_labels'].values():
                self.canvas.delete(lid)
        
        # Delete arrows
        for arrow_id in unit['arrows']:
            self.canvas.delete(arrow_id)
            if arrow_id in self.arrows:
                del self.arrows[arrow_id]
        
        # Delete points and their number labels
        for point_id in [unit['blue'], unit['yellow'], unit['red']]:
            if point_id in self.selected_points:
                self.selected_points.remove(point_id)
                self.canvas.itemconfig(point_id, outline="", width=1)
            if point_id in self.point_to_group:
                gidx = self.point_to_group[point_id]
                if gidx < len(self.linked_groups) and point_id in self.linked_groups[gidx]:
                    self.linked_groups[gidx].remove(point_id)
                    if not self.linked_groups[gidx]:
                        del self.linked_groups[gidx]
                        # Update indices
                        for higher_p, higher_idx in list(self.point_to_group.items()):
                            if higher_idx > gidx:
                                self.point_to_group[higher_p] -= 1
                del self.point_to_group[point_id]
            self.canvas.delete(point_id)
            if point_id in self.point_number_labels:
                self.canvas.delete(self.point_number_labels[point_id])
                del self.point_number_labels[point_id]
            if point_id in self.points:
                del self.points[point_id]
            if point_id in self.point_units:
                del self.point_units[point_id]
            if point_id in self.point_numbers:
                del self.point_numbers[point_id]
    
    def reset_all(self):
        # Cancel all timers (GUARDED)
        if self.is_premium and hasattr(self, 'fixed_timers'):
            for after_id in list(self.fixed_timers.values()):
                self.root.after_cancel(after_id)
            self.fixed_timers.clear()
        
        # Delete all canvas items
        self.canvas.delete("all")
        
        # Clear all state variables
        self.points.clear()
        self.arrows.clear()
        self.units.clear()
        self.point_units.clear()
        self.point_numbers.clear()
        self.point_number_labels.clear()
        self.selected_points.clear()
        self.linked_groups.clear()
        self.point_to_group.clear()
        self.selected_units.clear()
        self.selected_outputs.clear()
        self.cell_links.clear()
        self.cell_graph.clear()
        # PREMIUM: Guarded clears
        if self.is_premium:
            if hasattr(self, 'point_steps'):
                self.point_steps.clear()
            if hasattr(self, 'report_positions'):
                self.report_positions.clear()
            self.next_report_y = 30
        self.texts.clear()
        self.text_handles.clear()
        self.dragging_item = None
        self.dragging_type = None
        self.dragging_text_id = None
        self.dragging_units = None
        self.initial_positions = None
        self.init_mouse_x = None
        self.init_mouse_y = None
        self.init_drag_x = None
        self.init_drag_y = None
        self.next_unit_id = 1
        self.editing_entry = None
        self.editing_text = None
        self.editing_text_widget = None
        self.new_text_pos = None
        self.red_context_point = None
        self.yellow_context_point = None
        self.context_text_id = None
        if self.editing_text_widget:
            self.cancel_edit_text()
    
    def start_drag(self, event):
        items = self.canvas.find_closest(event.x, event.y)
        if not items:
            return
        clicked_item = items[0]
        tags = self.canvas.gettags(clicked_item)
        if "point" not in tags and "text_handle" not in tags:
            return
        self.dragging_item = clicked_item
        if "point" in tags:
            point_id = self.dragging_item
            unit_id = self.point_units.get(point_id)
            self.dragging_type = None
            if unit_id and unit_id in self.selected_units:
                self.dragging_type = 'group'
                self.dragging_units = list(self.selected_units)
                self.initial_positions = {}
                for uid in self.dragging_units:
                    u = next((u for u in self.units if u['unit_id'] == uid), None)
                    if u:
                        for col in ['blue', 'yellow', 'red']:
                            p_id = u[col]
                            self.initial_positions[p_id] = self.points[p_id][:2]
                self.init_mouse_x = event.x
                self.init_mouse_y = event.y
            else:
                self.dragging_type = 'point'
        elif "text_handle" in tags:
            # Parse text_id from tags
            text_id_str = [t for t in tags if t.isdigit()][0]
            self.dragging_text_id = int(text_id_str)
            self.dragging_type = 'text'
    
    def drag_item(self, event):
        if self.dragging_item is None or self.dragging_type is None:
            return
        item_id = self.dragging_item
        if self.dragging_type == 'point':
            if self.dragging_type == 'group':  # Note: dragging_type set to 'group' overrides 'point'
                dx = event.x - self.init_mouse_x
                dy = event.y - self.init_mouse_y
                # Update points
                for p_id, (ix, iy) in self.initial_positions.items():
                    nx = ix + dx
                    ny = iy + dy
                    radius = 8
                    self.canvas.coords(p_id, nx - radius, ny - radius, nx + radius, ny + radius)
                    self.points[p_id] = (nx, ny, self.points[p_id][2])
                    # Update number labels
                    if p_id in self.point_number_labels:
                        l_id = self.point_number_labels[p_id]
                        self.canvas.coords(l_id, nx + 15, ny + 15)
                # Collect arrows for dragging units
                all_arrows = set()
                for uid in self.dragging_units:
                    u = next((u for u in self.units if u['unit_id'] == uid), None)
                    if u:
                        all_arrows.update(u['arrows'])
                # Update arrows
                for a_id in all_arrows:
                    if a_id in self.arrows:
                        s_id, t_id = self.arrows[a_id]
                        sx, sy = self.points[s_id][:2]
                        tx, ty = self.points[t_id][:2]
                        self.canvas.coords(a_id, sx, sy, tx, ty)
                # Update link arrows if any connected points moved
                moved_points = set(self.initial_positions.keys())
                for link in self.cell_links:
                    if link['start'] in moved_points or link['end'] in moved_points:
                        sx, sy = self.points[link['start']][:2]
                        ex, ey = self.points[link['end']][:2]
                        self.canvas.coords(link['arrow_id'], sx, sy, ex, ey)
                # Update operation labels
                for uid in self.dragging_units:
                    u = next((u for u in self.units if u['unit_id'] == uid), None)
                    if not u:
                        continue
                    # Addition/Multiplication label
                    if u.get('operation_label'):
                        l_id = u['operation_label']
                        b_id = u['blue']
                        bx, by = self.points[b_id][:2]
                        self.canvas.coords(l_id, bx, by - 20)
                    # Logarithmic labels
                    if u.get('operation') == 'logarithmic' and 'operation_labels' in u:
                        op_labels = u['operation_labels']
                        for color, l_id in op_labels.items():
                            if color == 'yellow':
                                p_id = u['yellow']
                            elif color == 'blue':
                                p_id = u['blue']
                            elif color == 'red':
                                p_id = u['red']
                            else:
                                continue
                            px, py = self.points[p_id][:2]
                            self.canvas.coords(l_id, px, py - 20)
            else:
                x, y = event.x, event.y
                radius = 8
                # Update point coordinates
                self.canvas.coords(item_id, x - radius, y - radius, x + radius, y + radius)
                self.points[item_id] = (x, y, self.points[item_id][2])
                
                # Update arrows connected to this point
                for arrow_id, (source_id, target_id) in self.arrows.items():
                    source_x, source_y, _ = self.points[source_id]
                    target_x, target_y, _ = self.points[target_id]
                    if source_id == item_id or target_id == item_id:
                        self.canvas.coords(arrow_id, source_x, source_y, target_x, target_y)
                
                # Update link arrows connected to this point
                for link in self.cell_links:
                    if link['start'] == item_id or link['end'] == item_id:
                        s_id = link['start']
                        e_id = link['end']
                        sx, sy = self.points[s_id][:2]
                        ex, ey = self.points[e_id][:2]
                        self.canvas.coords(link['arrow_id'], sx, sy, ex, ey)
                
                # Update number label position
                if item_id in self.point_number_labels:
                    label_id = self.point_number_labels[item_id]
                    self.canvas.coords(label_id, x + 15, y + 15)
                
                # Update operation label(s) if applicable
                unit_id = self.point_units.get(item_id)
                if unit_id:
                    unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
                    if unit:
                        if unit.get('operation') == 'logarithmic' and 'operation_labels' in unit:
                            # Determine which point is being dragged
                            if item_id == unit['yellow']:
                                color_key = 'yellow'
                            elif item_id == unit['blue']:
                                color_key = 'blue'
                            elif item_id == unit['red']:
                                color_key = 'red'
                            else:
                                color_key = None
                            if color_key and color_key in unit['operation_labels']:
                                op_label_id = unit['operation_labels'][color_key]
                                self.canvas.coords(op_label_id, x, y - 20)
                        elif unit.get('operation_label') and item_id == unit['blue']:
                            # For addition/multiplication, move label if dragging blue point
                            op_label_id = unit['operation_label']
                            self.canvas.coords(op_label_id, x, y - 20)
        elif self.dragging_type == 'text':
            text_id = self.dragging_text_id
            x, y = event.x, event.y
            self.canvas.coords(text_id, x, y)
            handle_id = self.text_handles.get(text_id)
            if handle_id:
                self.canvas.coords(handle_id, x-3, y-3, x+3, y+3)
            if text_id in self.texts:
                ox, oy, c = self.texts[text_id]
                self.texts[text_id] = (x, y, c)
    
    def stop_drag(self, event):
        self.dragging_item = None
        self.dragging_type = None
        self.dragging_text_id = None
        self.dragging_units = None
        self.initial_positions = None
        self.init_mouse_x = None
        self.init_mouse_y = None
        self.init_drag_x = None
        self.init_drag_y = None
    
    def handle_double_click(self, event):
        # Check for link arrow double-click
        overlap_items = self.canvas.find_overlapping(event.x - 3, event.y - 3, event.x + 3, event.y + 3)
        link_item = None
        for item in overlap_items:
            if "link_arrow" in self.canvas.gettags(item):
                link_item = item
                break
        if link_item:
            link = next((l for l in self.cell_links if l['arrow_id'] == link_item), None)
            if link:
                old_start, old_end = link['start'], link['end']
                link['start'], link['end'] = old_end, old_start
                self.cell_graph[old_start].remove(old_end)
                self.cell_graph[old_end].append(old_start)
                # Update arrow coords
                nsx, nsy, _ = self.points[link['start']]
                nex, ney, _ = self.points[link['end']]
                self.canvas.coords(link['arrow_id'], nsx, nsy, nex, ney)
                # Propagate from new start
                self.propagate_update(link['start'], self.point_numbers[link['start']])
            return "break"
        
        # Check for text
        items = self.canvas.find_closest(event.x, event.y)
        if items and "text" in self.canvas.gettags(items[0]):
            self.on_text_double_click(event)
            return "break"
        
        # Original point handling
        if items and "point" in self.canvas.gettags(items[0]):
            clicked_point = items[0]
            
            # Find the unit containing the clicked point
            unit_id = self.point_units.get(clicked_point)
            if not unit_id:
                return "break"
            unit = next((u for u in self.units if u['unit_id'] == unit_id), None)
            if not unit:
                return "break"
                
            # If the clicked point is already the output, no change needed
            if clicked_point == unit['output']:
                return "break"
                
            # New output point
            new_output_id = clicked_point
            new_output_x, new_output_y, _ = self.points[new_output_id]
            
            # Determine new input points (the other two points)
            all_points = {unit['blue'], unit['yellow'], unit['red']}
            all_points.remove(new_output_id)
            new_input1_id, new_input2_id = list(all_points)  # Unpack the remaining two points
            
            # Update arrows: input1 -> output, input2 -> output
            arrow1_id, arrow2_id = unit['arrows']
            input1_x, input1_y, _ = self.points[new_input1_id]
            input2_x, input2_y, _ = self.points[new_input2_id]
            
            # Update arrow mappings and coordinates
            self.arrows[arrow1_id] = (new_input1_id, new_output_id)
            self.arrows[arrow2_id] = (new_input2_id, new_output_id)
            self.canvas.coords(arrow1_id, input1_x, input1_y, new_output_x, new_output_y)
            self.canvas.coords(arrow2_id, input2_x, input2_y, new_output_x, new_output_y)
            
            # Update unit dictionary
            unit['output'] = new_output_id
            unit['input1'] = new_input1_id
            unit['input2'] = new_input2_id
            
            # Do not move operation label for addition/multiplication; it stays with blue
            # For logarithmic, labels stay with their respective points
            
            # Update numbers if an operation is enabled
            self.update_unit_numbers(unit_id)
            return "break"
        else:
            # Create new text
            self.start_new_text(event.x, event.y)
            return "break"

if __name__ == "__main__":
    root = tk.Tk()
    app = WhiteboardApp(root)
    root.mainloop()
